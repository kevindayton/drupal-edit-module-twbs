<?php

/**
 * @file
 * Provides in-place content editing functionality for fields.
 *
 * The Edit module makes content editable in-place. Rather than having to visit
 * a separate page to edit content, it may be edited in-place.
 *
 * Technically, this module adds classes and data- attributes to fields and
 * entities, enabling them for in-place editing.
 */

use Drupal\Core\Template\Attribute;
use Drupal\field\FieldInstance;

// @todo: POSTPONED_ON(Drupal core, http://drupal.org/node/1839516)
// Remove this when Entity Access API is ready.
// Edit needs the Entity Access API. Sadly, http://drupal.org/node/1696660 is
// just the framework, it still needs to be used; currently it will simply
// always return FALSE (i.e. "no access").
function edit_entity_access($op, $entity_type, $entity = NULL, $account = NULL) {
  if ($entity_type == 'node') {
    return node_access($op, $entity, $account);
  }

  // Currently, only editing of nodes is supported. See the above issue.
  return FALSE;
}

/**
 * Implements hook_menu()
 */
function edit_menu() {
  $items = array();
  $items['admin/edit/field/%/%/%/%/%'] = array(
    // Access is controlled after we have inspected the entity, which can't
    // easily happen until after the callback.
    'access arguments' => array(TRUE),
    'access callback'  => TRUE,
    'page callback'    => 'edit_field_edit',
    'page arguments'   => array(3, 4, 5, 6, 7),
    'file'             => 'includes/pages.inc',
    'delivery callback'=> 'ajax_deliver',
    'theme callback'   => 'ajax_base_page_theme',
  );
  $items['admin/render-without-transformations/field/%/%/%/%/%'] = array(
    // Access is controlled after we have inspected the entity, which can't
    // easily happen until after the callback.
    'access arguments' => array(TRUE),
    'access callback'  => TRUE,
    'page callback'    => 'edit_text_field_render_without_transformation_filters',
    'page arguments'   => array(3, 4, 5, 6, 7),
    'file'             => 'includes/pages.inc',
    'delivery callback'=> 'ajax_deliver',
    'theme callback'   => 'ajax_base_page_theme',
  );

  return $items;
}

/**
 * Implements hook_toolbar().
 */
function edit_toolbar() {
  if (path_is_admin(current_path())) {
    return;
  }

  $tab['edit'] = array(
    'tab' => array(
      'title' => t('Edit'),
      'href' => '',
      'html' => FALSE,
      'attributes' => array(
        'class' => array('icon', 'icon-edit'),
      ),
      // @todo: BLOCKED_ON(Drupal core, http://drupal.org/node/1847198)
      // This #post_render callback does not yet get called, which means that
      // even if zero fields on the current page are editable for the current
      // user, the "Edit" tab will still show up.
      '#post_render' => array(
        'edit_toolbar_post_render',
      ),
    ),
    'tray' => array(
      'view_edit_toggle' => array(
        '#prefix' => '<h2 class="element-invisible">' . t('In-place edit operations') . '</h2><ul id="edit_view-edit-toggles" class="menu">',
        '#suffix' => '</ul>',
        'content' => array(
          array(
            '#theme' => 'menu_local_task',
            '#link' => array('title' => t('View'), 'href' => current_path(), 'localized_options' => array('fragment' => 'view', 'attributes' => array('class' => array('edit_view-edit-toggle', 'edit-view')))),
            '#active' => TRUE,
          ),
          array(
            '#theme' => 'menu_local_task',
            '#link' => array('title' => t('Quick edit'), 'href' => current_path(), 'localized_options' => array('fragment' => 'quick-edit', 'attributes' => array('class' => array('edit_view-edit-toggle', 'edit-edit')))),
          ),
        ),
        '#attached' => array(
          'library' => array(
            array('edit', 'edit'),
          ),
        ),
      ),
      '#post_render' => array(
        'edit_toolbar_post_render',
      ),
    ),
  );

  return $tab;
}

/**
 * Post-render function to only show the Edit tab in the toolbar if relevant.
 *
 * When the user cannot edit any of the fields on the page, he should not be
 * given the possibility to toggle edit mode.
 */
function edit_toolbar_post_render($html) {
  global $edit_toolbar;
  return ($edit_toolbar !== TRUE) ? '' : $html;
}

/**
 * Implements hook_library().
 */
function edit_library_info() {
  $path = drupal_get_path('module', 'edit');
  $libraries['edit'] = array(
    'title' => 'Edit: in-place editing',
    'website' => 'http://drupal.org/project/edit',
    'version' => VERSION,
    'js' => array(
      // Core.
      $path . '/js/edit.js' => array('defer' => TRUE),
      $path . '/js/app.js' => array('defer' => TRUE),
      // Routers.
      $path . '/js/routers/edit-router.js' => array('defer' => TRUE),
      // Models.
      $path . '/js/models/edit-app-model.js' => array('defer' => TRUE),
      // Views.
      $path . '/js/views/propertyeditordecoration-view.js' => array('defer' => TRUE),
      $path . '/js/views/menu-view.js' => array('defer' => TRUE),
      $path . '/js/views/modal-view.js' => array('defer' => TRUE),
      $path . '/js/views/overlay-view.js' => array('defer' => TRUE),
      $path . '/js/views/toolbar-view.js' => array('defer' => TRUE),
      // Backbone.sync implementation on top of Drupal forms.
      $path . '/js/backbone.drupalform.js' => array('defer' => TRUE),
      // VIE service.
      $path . '/js/viejs/EditService.js' => array('defer' => TRUE),
      // Create.js subclasses.
      $path . '/js/createjs/editable.js' => array('defer' => TRUE),
      $path . '/js/createjs/storage.js' => array('defer' => TRUE),
      $path . '/js/createjs/editingWidgets/formwidget.js' => array('defer' => TRUE),
      $path . '/js/createjs/editingWidgets/drupalcontenteditablewidget.js' => array('defer' => TRUE),
      $path . '/js/createjs/editingWidgets/drupalalohawidget.js' => array('defer' => TRUE),
      // Other.
      $path . '/js/util.js' => array('defer' => TRUE),
      $path . '/js/theme.js' => array('defer' => TRUE),
      // Basic settings.
      array(
        'data' => array('edit' => array(
          'fieldFormURL' => url('admin/edit/field/!entity_type/!id/!field_name/!langcode/!view_mode'),
          'rerenderProcessedTextURL' => url('admin/render-without-transformations/field/!entity_type/!id/!field_name/!langcode/!view_mode'),
          'context' => 'body',
        )),
        'type' => 'setting',
      ),
    ),
    'css' => array(
      $path . '/css/edit.css',
    ),
    'dependencies' => array(
      array('system', 'jquery'),
      array('system', 'underscore'),
      array('system', 'backbone'),
      array('system', 'vie.core'),
      array('system', 'create.editonly'),
      array('system', 'jquery.form'),
      array('system', 'drupal.form'),
      array('system', 'drupal.ajax'),
    ),
  );

  // Only add dependencies on the WYSIWYG editor when it's actually available.
  if (count(module_implements('edit_wysiwyg_info'))) {
    $libraries['edit']['dependencies'][] = _edit_get_wysiwyg_info('javascript library');
  }

  return $libraries;
}

/**
 * Implements hook_field_attach_view_alter().
 */
function edit_field_attach_view_alter(&$output, $context) {
  // Special case for this special mode.
  if ($context['display'] == 'edit-render-without-transformation-filters') {
    $children = element_children($output);
    $field_name = reset($children);
    $langcode = $output[$field_name]['#language'];
    foreach (array_keys($output[$field_name]['#items']) as $item) {
      $text      = $output[$field_name]['#items'][$item]['value'];
      $format_id = $output[$field_name]['#items'][$item]['format'];
      $untransformed = check_markup($text, $format_id, $langcode, FALSE, array(FILTER_TYPE_TRANSFORM_REVERSIBLE, FILTER_TYPE_TRANSFORM_IRREVERSIBLE));
      $output[$field_name][$item]['#markup'] = $untransformed;
    }
  }
}

/**
 * Implements hook_preprocess_HOOK() for field.tpl.php.
 */
function edit_preprocess_field(&$variables) {
  $entity = $variables['element']['#object'];
  $field_name = $variables['element']['#field_name'];
  $langcode = $variables['element']['#language'];
  $view_mode = $variables['element']['#view_mode'];
  $formatter_type = $variables['element']['#formatter'];
  $items = $entity->{$field_name}[$langcode];;
  $instance = field_info_instance($entity->entityType(), $field_name, $entity->bundle());

  $entity_access = edit_entity_access('update', $entity->entityType(), $entity);
  $field_access = field_access('edit', $field_name, $entity->entityType(), $entity);
  $editability = _edit_analyze_field_editability($items, $instance, $formatter_type);
  if ($entity_access && $field_access && $editability != 'disabled') {
    global $edit_toolbar;
    $edit_toolbar = TRUE;

    // Mark this field as editable and provide metadata through data- attributes.
    $variables['attributes']['data-edit-field-label'] = $instance->definition['label'];
    $variables['attributes']['data-edit-id'] = $entity->entityType() . ':' . $entity->id() . ':' . $field_name . ':' . $langcode . ':' . $view_mode;
    $variables['attributes']['class'][] = 'edit-field';
    $variables['attributes']['class'][] = 'edit-allowed';
    $variables['attributes']['class'][] = 'edit-type-' . $editability;
    if ($editability == 'direct-with-wysiwyg') {
      $variables['attributes']['class'][] = 'edit-type-direct';
      $format_id = $entity->{$field_name}[$langcode][0]['format'];
      _edit_preprocess_field_wysiwyg($variables, $format_id);
    }
  }
}

/**
 * Sets attributes on a field that have 'direct-with-wysiwyg' editability.
 *
 * @param array $variables
 *   An associative array containing: the key 'attributes'. See the
 *   theme_field() function for information about these variables.
 * @param string $format_id
 *   A text format id.
 *
 * @see theme_field()
 */
function _edit_preprocess_field_wysiwyg(&$variables, $format_id) {
  // Let the WYSIWYG editor know the text format.
  $variables['attributes']['data-edit-text-format'] = $format_id;

  // Ensure the WYSIWYG editor has the necessary text format related
  // metadata.
  $settings_callback = _edit_get_wysiwyg_info('javascript settings callback');
  $settings_callback();

  // Let the JavaScript logic know whether transformation filters are used
  // in this format, so it can decide whether to re-render the text or not.
  $filter_types = filter_get_filter_types_by_format($format_id);
  $transformation_filter_types = array(
    FILTER_TYPE_TRANSFORM_REVERSIBLE,
    FILTER_TYPE_TRANSFORM_IRREVERSIBLE
  );
  if (count(array_intersect($transformation_filter_types, $filter_types))) {
    $variables['attributes']['class'][] = 'edit-text-with-transformation-filters';
  }
  else {
    $variables['attributes']['class'][] = 'edit-text-without-transformation-filters';
  }
}

/**
 * Determines editability given a field, its instance info and its formatter.
 *
 * @param array $field
 *   The field's field array.
 * @param FieldInstance $instance
 *   The field's instance info.
 * @param string $formatter_type
 *   The field's formatter type name.
 *
 * @return string
 *   The editability: 'disabled', 'form', 'direct' or 'direct-with-wysiwyg'.
 */
function _edit_analyze_field_editability($items, FieldInstance $instance, $formatter_type) {
  $field_name = $instance['field_name'];

  // If the formatter doesn't contain the edit property, default it to 'form'
  // editability, which should always work.
  $formatter_info = field_info_formatter_types($formatter_type);
  if (empty($formatter_info['edit']['editability'])) {
    $formatter_info['edit']['editability'] = 'form';
  }

  $editability = $formatter_info['edit']['editability'];

  // If editing is explicitly disabled for this field, return early to avoid
  // any further processing.
  if ($editability == 'disabled') {
    return;
  }

  // If directly editable, check the cardinality. If the cardinality is greater
  // than 1, use a form to edit the field.
  if ($editability == 'direct') {
    $field = field_info_field($field_name);
    if ($field['cardinality'] != 1) {
      $editability = 'form';
    }
  }

  // If still directly editable, check whether "regular" direct editing (almost
  // bare contentEditable) editing should be used or WYSIWYG-based direct
  // editing should be used. In the latter case
  if ($editability == 'direct') {
    // If this field is configured to not use text processing; it is plain text
    // "regular" direct editing should be used, which is already set.
    // On the other hand, if it is configured to use text processing; then we
    // must check whether 'direct-with-wysiwyg' or 'form' editability should be
    // used.
    if (!empty($instance['settings']['text_processing'])) {
      $format_id = $items[0]['format'];
      $editability = _edit_wysiwyg_analyze_field_editability($format_id);
    }
  }

  return $editability;
}

/**
 * Determines editability given a directly editable field with text processing.
 *
 * Given a text field (with cardinality 1) that defaults to 'direct' editability
 * and has text processing enabled, check whether the text format allows it to
 * use WYSIWYG-powered direct editing or whether 'form' based editing needs to
 * be used.
 *
 * @param string|NULL $format_id
 *   The field's current text format.
 *
 * @return string
 *   The editability: 'direct-with-wysiwyg' or 'form'.
 */
function _edit_wysiwyg_analyze_field_editability($format_id = NULL) {
  // If no format is assigned yet, (e.g. when the field is still empty (NULL)),
  // then provide form-based editing, so that the user is able to select a text
  // format. (Direct editing doesn't allow the user to change the format.)
  if (empty($format_id)) {
    return 'form';
  }
  // If no WYSIWYG editor is available, then fall back to form-based editing.
  elseif (count(_edit_get_wysiwyg_info()) == 0) {
    return 'form';
  }
  // If the WYSIWYG editor is not compatible with the current format, then fall
  // back to form-based editing.
  else {
    $compatibility_callback = _edit_get_wysiwyg_info('format compatibility callback');
    if (!$compatibility_callback($format_id)) {
      return 'form';
    }
  }

  return 'direct-with-wysiwyg';
}

/**
 * Retrieves a list of all available WYSIWYG integration for Edit. Only the
 * first is actually used.
 *
 * @todo Convert to the plug-in system!
 *
 * @param string $key
 *   The key to get a value for.
 *
 * @see hook_edit_wysiwyg_info()
 * @see hook_edit_wysiwyg_info_alter()
 */
function _edit_get_wysiwyg_info($key = NULL) {
  $edit_wysiwyg_info = &drupal_static(__FUNCTION__, array());

  if (empty($edit_wysiwyg_info)) {
    $cache = cache()->get('edit_wysiwyg_info');
    if ($cache === FALSE) {
      // Rebuild the cache and save it.
      $edit_wysiwyg_info = module_invoke_all('edit_wysiwyg_info');
      drupal_alter('edit_wysiwyg_info', $edit_wysiwyg_info);
    }
    else {
      $edit_wysiwyg_info = $cache->data;
    }
  }

  if (isset($key)) {
    $modules = array_keys($edit_wysiwyg_info);
    $first = $modules[0];

    return $edit_wysiwyg_info[$first][$key];
  }
  else {
    return $edit_wysiwyg_info;
  }
}
